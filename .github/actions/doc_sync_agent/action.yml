name: 'Doc Sync Agent'
description: 'Automatically sync documentation (README.md, CLAUDE.md) when code changes are merged'
author: 'Deriv'

inputs:
  github_token:
    description: 'GitHub PAT with contents:write and pull-requests:write permissions'
    required: true
  anthropic_api_key:
    description: 'Anthropic API key for Claude'
    required: true
  slack_webhook_url:
    description: 'Slack webhook URL for #docsync_private channel'
    required: true
  slack_users_to_tag:
    description: 'Comma-separated Slack user IDs to tag in notifications (e.g., U123ABC,U456DEF)'
    required: false
    default: ''
  repository:
    description: 'Repository name (owner/repo)'
    required: true
  commit_sha:
    description: 'Commit SHA that triggered this workflow'
    required: true
  base_branch:
    description: 'Base branch name (main or master)'
    required: false
    default: 'master'
  docs_to_check:
    description: 'Comma-separated list of documentation files to check'
    required: false
    default: 'README.md,CLAUDE.md'

outputs:
  pr_created:
    description: 'Whether a PR was created (true/false)'
    value: ${{ steps.create-pr.outputs.pr_created }}
  pr_url:
    description: 'URL of the created PR (if any)'
    value: ${{ steps.create-pr.outputs.pr_url }}
  pr_number:
    description: 'Number of the created PR (if any)'
    value: ${{ steps.create-pr.outputs.pr_number }}
  files_updated:
    description: 'Comma-separated list of files updated'
    value: ${{ steps.update-files.outputs.files_updated }}
  claude_reasoning:
    description: "Claude's reasoning for the decision"
    value: ${{ steps.analyze.outputs.reasoning }}
  status:
    description: 'Overall status (success/skipped/failed)'
    value: ${{ steps.finalize.outputs.status }}

runs:
  using: 'composite'
  steps:
    # Step 1: Checkout Repository
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 50
        token: ${{ inputs.github_token }}

    # Step 2: Extract PR Context
    - name: Extract PR context
      id: pr-info
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        COMMIT_SHA: ${{ inputs.commit_sha }}
      run: |
        set -e

        echo "Extracting PR information for commit: $COMMIT_SHA"

        # Find merged PR from commit SHA
        PR_INFO=$(gh pr list --search "$COMMIT_SHA" --state merged --json number,title,url --jq '.[0]' || echo '{}')

        PR_NUMBER=$(echo "$PR_INFO" | jq -r '.number // "N/A"')
        PR_TITLE=$(echo "$PR_INFO" | jq -r '.title // "Direct commit"')
        PR_URL=$(echo "$PR_INFO" | jq -r '.url // "N/A"')

        echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
        echo "pr_title=$PR_TITLE" >> $GITHUB_OUTPUT
        echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT

        echo "## PR Information" >> $GITHUB_STEP_SUMMARY
        echo "- PR Number: $PR_NUMBER" >> $GITHUB_STEP_SUMMARY
        echo "- PR Title: $PR_TITLE" >> $GITHUB_STEP_SUMMARY
        echo "- Commit: $COMMIT_SHA" >> $GITHUB_STEP_SUMMARY

    # Step 3: Generate Diff
    - name: Generate diff context
      id: diff-context
      shell: bash
      run: |
        set -e

        echo "Generating diff context..."

        # Determine if this is a merge commit
        if git rev-parse --verify HEAD^2 2>/dev/null; then
          echo "Detected merge commit"
          MERGE_BASE=$(git merge-base HEAD~1 HEAD)
          DIFF=$(git diff "$MERGE_BASE" HEAD 2>/dev/null || git diff HEAD~1 HEAD)
        else
          echo "Regular commit, comparing with previous"
          DIFF=$(git diff HEAD~1 HEAD 2>/dev/null || echo "No diff available")
        fi

        # Filter noise (exclude lock files, binary files, and limit size)
        FILTERED_DIFF=$(echo "$DIFF" | grep -v "package-lock.json" | grep -v "yarn.lock" | grep -v "pnpm-lock.yaml" | grep -v ".lock" | head -n 5000)

        # Count changed files
        CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | wc -l)

        echo "changed_files=$CHANGED_FILES" >> $GITHUB_OUTPUT

        # Save diff to file for next step
        echo "$FILTERED_DIFF" > /tmp/code_diff.txt

        echo "## Code Changes" >> $GITHUB_STEP_SUMMARY
        echo "- Changed files: $CHANGED_FILES" >> $GITHUB_STEP_SUMMARY
        echo "- Diff size: $(echo "$FILTERED_DIFF" | wc -l) lines" >> $GITHUB_STEP_SUMMARY

    # Step 4: Read Current Documentation
    - name: Read current documentation
      id: read-docs
      shell: bash
      run: |
        set -e

        echo "Reading current documentation..."

        # Read README.md
        if [ -f "README.md" ]; then
          README_CONTENT=$(cat README.md)
          README_EXISTS="true"
        else
          README_CONTENT=""
          README_EXISTS="false"
        fi

        # Read CLAUDE.md
        if [ -f "CLAUDE.md" ]; then
          CLAUDE_MD_CONTENT=$(cat CLAUDE.md)
          CLAUDE_MD_EXISTS="true"
        else
          CLAUDE_MD_CONTENT=""
          CLAUDE_MD_EXISTS="false"
        fi

        echo "readme_exists=$README_EXISTS" >> $GITHUB_OUTPUT
        echo "claude_md_exists=$CLAUDE_MD_EXISTS" >> $GITHUB_OUTPUT

        # Save content to files
        echo "$README_CONTENT" > /tmp/current_readme.txt
        echo "$CLAUDE_MD_CONTENT" > /tmp/current_claude_md.txt

        echo "## Current Documentation" >> $GITHUB_STEP_SUMMARY
        echo "- README.md exists: $README_EXISTS" >> $GITHUB_STEP_SUMMARY
        echo "- CLAUDE.md exists: $CLAUDE_MD_EXISTS" >> $GITHUB_STEP_SUMMARY

    # Step 5: Analyze with Claude AI
    - name: Analyze with Claude AI
      id: analyze
      shell: bash
      env:
        ANTHROPIC_API_KEY: ${{ inputs.anthropic_api_key }}
        REPOSITORY: ${{ inputs.repository }}
        PR_TITLE: ${{ steps.pr-info.outputs.pr_title }}
        COMMIT_SHA: ${{ inputs.commit_sha }}
      run: |
        set -e

        echo "Calling Claude AI for analysis..."

        # Read prepared files
        DIFF_CONTENT=$(cat /tmp/code_diff.txt)
        README_CONTENT=$(cat /tmp/current_readme.txt)
        CLAUDE_MD_CONTENT=$(cat /tmp/current_claude_md.txt)

        # Build system prompt
        SYSTEM_PROMPT="You are an expert software architect and technical writer with deep expertise in:
        - Understanding code architecture and impact analysis
        - Technical writing and documentation best practices
        - Identifying when changes affect public APIs, workflows, or user-facing features
        - Creating clear, comprehensive documentation that follows existing style and structure

        Your role is to analyze code changes and determine if project documentation needs to be updated. You make intelligent decisions about what warrants documentation updates and generate high-quality content when needed.

        CRITICAL: Be conservative with updates. Documentation should ONLY be updated for significant, user-facing changes. DO NOT update documentation for:
        - Minor bug fixes that don't change functionality
        - Small UI tweaks (styling, colors, spacing)
        - Internal code refactoring
        - Dependency version bumps
        - Code formatting or linting changes
        - Internal variable/function renames
        - Performance optimizations that don't affect usage

        Only update when changes genuinely impact how users understand or interact with the project."

        # Build user prompt
        USER_PROMPT="Repository: $REPOSITORY
        Merged PR/Commit: $PR_TITLE
        Commit SHA: $COMMIT_SHA

        ## Code Changes
        \`\`\`diff
        $DIFF_CONTENT
        \`\`\`

        ## Current Documentation

        ### Current README.md
        $(if [ -n "$README_CONTENT" ]; then echo "\`\`\`markdown"; echo "$README_CONTENT"; echo "\`\`\`"; else echo "(File does not exist)"; fi)

        ### Current CLAUDE.md
        $(if [ -n "$CLAUDE_MD_CONTENT" ]; then echo "\`\`\`markdown"; echo "$CLAUDE_MD_CONTENT"; echo "\`\`\`"; else echo "(File does not exist)"; fi)

        ## Your Task
        Analyze the code changes and determine:
        1. Do these changes require README.md updates? Consider:
           - New features or functionality
           - Changes to setup/installation instructions
           - API or usage changes
           - Configuration changes
           - Dependency changes that affect users

        2. Do these changes require CLAUDE.md updates? Consider:
           - AI/LLM integration changes
           - Claude-specific workflows or prompts
           - Architecture changes relevant to AI assistants
           - Development guidelines for AI tools

        3. If yes to either, generate the COMPLETE updated content (not diffs)

        ## Response Format
        Respond ONLY with valid JSON in this exact structure (no markdown code blocks, just raw JSON):
        {
          \"should_update_readme\": boolean,
          \"should_update_claude_md\": boolean,
          \"readme_content\": \"complete updated README.md content (only if should_update_readme is true, otherwise empty string)\",
          \"claude_md_content\": \"complete updated CLAUDE.md content (only if should_update_claude_md is true, otherwise empty string)\",
          \"reasoning\": \"Brief explanation of your decisions (2-4 sentences)\"
        }

        ## Important Guidelines
        - BE CONSERVATIVE: Only update documentation for significant, user-facing changes
        - Preserve existing formatting style and structure exactly
        - If files don't exist, only create them if changes strongly warrant documentation
        - Generate complete file content, not partial updates or diffs

        ## DO NOT Update Documentation For:
        - Minor bug fixes (unless they fix critical user-facing issues)
        - Small UI changes (button colors, spacing, font sizes, styling tweaks)
        - Internal code refactoring or reorganization
        - Dependency version bumps (unless they require user action)
        - Code formatting, linting, or style changes
        - Internal variable/function/class renames
        - Performance optimizations that don't affect how users interact
        - Test file changes or test coverage improvements
        - CI/CD configuration changes
        - Development tooling updates"

        # Call Claude API with timeout
        echo "Calling Claude API..."
        RESPONSE=$(timeout 120s curl -s -X POST "https://api.anthropic.com/v1/messages" \
          -H "x-api-key: $ANTHROPIC_API_KEY" \
          -H "anthropic-version: 2023-06-01" \
          -H "content-type: application/json" \
          -d "$(jq -n \
            --arg system "$SYSTEM_PROMPT" \
            --arg user "$USER_PROMPT" \
            '{
              "model": "claude-3-7-sonnet-latest",
              "max_tokens": 8000,
              "temperature": 0.3,
              "system": $system,
              "messages": [{
                "role": "user",
                "content": $user
              }]
            }')" || {
          echo "Claude API call failed or timed out"
          echo "api_success=false" >> $GITHUB_OUTPUT
          exit 1
        })

        # Check for API errors
        ERROR_MSG=$(echo "$RESPONSE" | jq -r '.error.message // empty')
        if [ -n "$ERROR_MSG" ]; then
          echo "Claude API error: $ERROR_MSG"
          echo "api_success=false" >> $GITHUB_OUTPUT
          echo "error_message=$ERROR_MSG" >> $GITHUB_OUTPUT
          exit 1
        fi

        # Extract content from response
        CLAUDE_DECISION=$(echo "$RESPONSE" | jq -r '.content[0].text')

        # Save to file
        echo "$CLAUDE_DECISION" > /tmp/claude_decision.json

        echo "api_success=true" >> $GITHUB_OUTPUT
        echo "## Claude AI Analysis Complete" >> $GITHUB_STEP_SUMMARY

    # Step 6: Parse Decision & Update Files
    - name: Parse decision and update files
      id: update-files
      shell: bash
      run: |
        set -e

        echo "Parsing Claude's decision..."

        # Read Claude's response
        CLAUDE_DECISION=$(cat /tmp/claude_decision.json)

        # #region agent log - DEBUG: Log raw Claude decision
        echo "::group::DEBUG - Raw Claude Decision"
        echo "$CLAUDE_DECISION"
        echo "::endgroup::"
        # #endregion

        # Validate JSON
        if ! echo "$CLAUDE_DECISION" | jq empty 2>/dev/null; then
          echo "Invalid JSON response from Claude"
          echo "valid_json=false" >> $GITHUB_OUTPUT
          echo "Response: $CLAUDE_DECISION"
          exit 1
        fi

        echo "valid_json=true" >> $GITHUB_OUTPUT

        # Extract decision
        SHOULD_UPDATE_README=$(echo "$CLAUDE_DECISION" | jq -r '.should_update_readme')
        SHOULD_UPDATE_CLAUDE_MD=$(echo "$CLAUDE_DECISION" | jq -r '.should_update_claude_md')
        REASONING=$(echo "$CLAUDE_DECISION" | jq -r '.reasoning')

        # #region agent log - DEBUG: Log extracted values
        echo "::group::DEBUG - Extracted Values"
        echo "SHOULD_UPDATE_README=$SHOULD_UPDATE_README"
        echo "SHOULD_UPDATE_CLAUDE_MD=$SHOULD_UPDATE_CLAUDE_MD"
        echo "REASONING=$REASONING"
        echo "::endgroup::"
        # #endregion

        echo "should_update_readme=$SHOULD_UPDATE_README" >> $GITHUB_OUTPUT
        echo "should_update_claude_md=$SHOULD_UPDATE_CLAUDE_MD" >> $GITHUB_OUTPUT
        echo "reasoning<<EOF" >> $GITHUB_OUTPUT
        echo "$REASONING" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

        # Check if any updates needed
        if [ "$SHOULD_UPDATE_README" = "false" ] && [ "$SHOULD_UPDATE_CLAUDE_MD" = "false" ]; then
          echo "No documentation updates needed"
          echo "has_updates=false" >> $GITHUB_OUTPUT
          echo "## âœ… No Updates Needed" >> $GITHUB_STEP_SUMMARY
          echo "$REASONING" >> $GITHUB_STEP_SUMMARY
          exit 0
        fi

        echo "has_updates=true" >> $GITHUB_OUTPUT

        # #region agent log - DEBUG: Confirm has_updates is set
        echo "::group::DEBUG - has_updates Output"
        echo "has_updates=true (set successfully)"
        echo "::endgroup::"
        # #endregion

        # Update files
        UPDATED_FILES=""

        if [ "$SHOULD_UPDATE_README" = "true" ]; then
          echo "Updating README.md..."
          README_CONTENT=$(echo "$CLAUDE_DECISION" | jq -r '.readme_content')

          # #region agent log - DEBUG: Log README content length
          echo "::group::DEBUG - README Content Check"
          echo "README_CONTENT length: ${#README_CONTENT}"
          echo "README_CONTENT first 200 chars: ${README_CONTENT:0:200}"
          echo "::endgroup::"
          # #endregion

          # Validate content is not empty
          if [ -z "$README_CONTENT" ] || [ "$README_CONTENT" = "null" ]; then
            echo "Warning: README content is empty, skipping"
          else
            echo "$README_CONTENT" > README.md
            UPDATED_FILES="README.md"
            echo "README.md updated"
            
            # #region agent log - DEBUG: Verify file was written
            echo "::group::DEBUG - README.md Write Verification"
            echo "File exists: $(test -f README.md && echo 'yes' || echo 'no')"
            echo "File size: $(wc -c < README.md) bytes"
            echo "::endgroup::"
            # #endregion
          fi
        fi

        if [ "$SHOULD_UPDATE_CLAUDE_MD" = "true" ]; then
          echo "Updating CLAUDE.md..."
          CLAUDE_MD_CONTENT=$(echo "$CLAUDE_DECISION" | jq -r '.claude_md_content')

          # Validate content is not empty
          if [ -z "$CLAUDE_MD_CONTENT" ] || [ "$CLAUDE_MD_CONTENT" = "null" ]; then
            echo "Warning: CLAUDE.md content is empty, skipping"
          else
            echo "$CLAUDE_MD_CONTENT" > CLAUDE.md
            if [ -n "$UPDATED_FILES" ]; then
              UPDATED_FILES="$UPDATED_FILES,CLAUDE.md"
            else
              UPDATED_FILES="CLAUDE.md"
            fi
            echo "CLAUDE.md updated"
          fi
        fi

        echo "files_updated=$UPDATED_FILES" >> $GITHUB_OUTPUT

        # #region agent log - DEBUG: Final state
        echo "::group::DEBUG - Final Update State"
        echo "UPDATED_FILES=$UPDATED_FILES"
        echo "Git status:"
        git status --short
        echo "::endgroup::"
        # #endregion

        echo "## ðŸ“ Files Updated" >> $GITHUB_STEP_SUMMARY
        echo "$UPDATED_FILES" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Reasoning:** $REASONING" >> $GITHUB_STEP_SUMMARY

    # Step 6.5: Debug - Verify outputs before PR step
    - name: Debug outputs before PR creation
      id: debug-outputs
      shell: bash
      run: |
        echo "::group::DEBUG - Step Outputs Verification"
        echo "has_updates: ${{ steps.update-files.outputs.has_updates }}"
        echo "files_updated: ${{ steps.update-files.outputs.files_updated }}"
        echo "should_update_readme: ${{ steps.update-files.outputs.should_update_readme }}"
        echo "should_update_claude_md: ${{ steps.update-files.outputs.should_update_claude_md }}"
        echo "api_success: ${{ steps.analyze.outputs.api_success }}"
        echo ""
        echo "Condition check: steps.update-files.outputs.has_updates == 'true'"
        echo "Actual value: '${{ steps.update-files.outputs.has_updates }}'"
        echo "Will PR step run? $([ '${{ steps.update-files.outputs.has_updates }}' = 'true' ] && echo 'YES' || echo 'NO')"
        echo "::endgroup::"

    # Step 7: Create Pull Request
    - name: Create pull request
      id: create-pr
      if: steps.update-files.outputs.has_updates == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        BASE_BRANCH: ${{ inputs.base_branch }}
        COMMIT_SHA: ${{ inputs.commit_sha }}
        REPOSITORY: ${{ inputs.repository }}
        PR_URL: ${{ steps.pr-info.outputs.pr_url }}
      run: |
        set -e

        echo "Creating pull request..."

        # #region agent log - DEBUG: Entry point and environment
        echo "::group::DEBUG - PR Creation Entry"
        echo "GH_TOKEN is set: $(test -n "$GH_TOKEN" && echo 'yes' || echo 'no')"
        echo "BASE_BRANCH=$BASE_BRANCH"
        echo "COMMIT_SHA=$COMMIT_SHA"
        echo "REPOSITORY=$REPOSITORY"
        echo "PR_URL=$PR_URL"
        echo "has_updates from previous step: ${{ steps.update-files.outputs.has_updates }}"
        echo "::endgroup::"
        # #endregion

        # Configure git
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        # #region agent log - DEBUG: Git state before branch creation
        echo "::group::DEBUG - Git State Before Branch"
        echo "Current branch: $(git rev-parse --abbrev-ref HEAD)"
        echo "Current commit: $(git rev-parse HEAD)"
        echo "Git status:"
        git status --short
        echo "Modified files:"
        git diff --name-only
        echo "::endgroup::"
        # #endregion

        # Create timestamped branch
        BRANCH="docs/auto-sync-$(date +%Y%m%d-%H%M%S)"
        git checkout -b "$BRANCH"

        # #region agent log - DEBUG: After branch creation
        echo "::group::DEBUG - After Branch Creation"
        echo "New branch: $BRANCH"
        echo "Current branch now: $(git rev-parse --abbrev-ref HEAD)"
        echo "::endgroup::"
        # #endregion

        # Get reasoning from previous step
        REASONING=$(cat /tmp/claude_decision.json | jq -r '.reasoning')
        FILES_UPDATED="${{ steps.update-files.outputs.files_updated }}"

        # Stage changes
        git add README.md CLAUDE.md 2>/dev/null || true

        # #region agent log - DEBUG: After staging
        echo "::group::DEBUG - After git add"
        echo "Staged files:"
        git diff --cached --name-only
        echo "Staged diff stats:"
        git diff --cached --stat
        echo "::endgroup::"
        # #endregion

        # Check if there are changes to commit
        if git diff --cached --quiet; then
          echo "No changes to commit after staging"
          # #region agent log - DEBUG: No changes detected
          echo "::group::DEBUG - No Changes Issue"
          echo "WARNING: git diff --cached --quiet returned true (no staged changes)"
          echo "README.md exists: $(test -f README.md && echo 'yes' || echo 'no')"
          echo "README.md size: $(wc -c < README.md 2>/dev/null || echo 'N/A') bytes"
          echo "CLAUDE.md exists: $(test -f CLAUDE.md && echo 'yes' || echo 'no')"
          echo "Full git status:"
          git status
          echo "::endgroup::"
          # #endregion
          echo "pr_created=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Commit
        git commit -m "docs: Auto-sync documentation for $COMMIT_SHA"

        # #region agent log - DEBUG: After commit
        echo "::group::DEBUG - After Commit"
        echo "Commit created successfully"
        echo "Latest commit: $(git log -1 --oneline)"
        echo "::endgroup::"
        # #endregion

        # Push branch
        echo "Pushing branch $BRANCH to origin..."
        git push origin "$BRANCH" 2>&1 || {
          # #region agent log - DEBUG: Push failed
          echo "::group::DEBUG - Push Failed"
          echo "ERROR: git push failed"
          echo "Remote URL: $(git remote get-url origin)"
          echo "::endgroup::"
          # #endregion
          echo "pr_created=false" >> $GITHUB_OUTPUT
          exit 1
        }

        # #region agent log - DEBUG: After push
        echo "::group::DEBUG - After Push"
        echo "Branch pushed successfully"
        echo "::endgroup::"
        # #endregion

        # Build PR body using printf for proper newline handling
        FILES_LIST=$(echo "$FILES_UPDATED" | tr ',' '\n' | sed 's/^/- /')
        
        PR_BODY=$(printf '%s\n\n%s\n\n%s\n%s\n\n%s\n%s\n\n%s\n%s\n%s\n\n%s\n%s' \
          "## ðŸ“š Automated Documentation Sync" \
          "This PR was automatically generated to keep documentation in sync with code changes." \
          "### Files Updated" \
          "$FILES_LIST" \
          "### Analysis by Claude AI (Architect Engineer)" \
          "$REASONING" \
          "### Triggered By" \
          "- Commit: \`${COMMIT_SHA}\`" \
          "- Original PR: ${PR_URL}" \
          "---" \
          "ðŸ¤– *Generated by [doc_sync_agent](https://github.com/${REPOSITORY}/.github/actions/doc_sync_agent) | Powered by Claude AI*")

        # #region agent log - DEBUG: Before PR creation
        echo "::group::DEBUG - Before PR Creation"
        echo "BASE_BRANCH for PR: $BASE_BRANCH"
        echo "HEAD branch for PR: $BRANCH"
        echo "PR_BODY length: ${#PR_BODY}"
        echo "::endgroup::"
        # #endregion

        # Create PR
        echo "Creating PR..."
        NEW_PR_URL=$(gh pr create \
          --title "ðŸ“š docs: Auto-sync documentation" \
          --body "$PR_BODY" \
          --base "$BASE_BRANCH" \
          --head "$BRANCH" 2>&1) || {
          # #region agent log - DEBUG: PR creation failed
          echo "::group::DEBUG - PR Creation Failed"
          echo "ERROR: gh pr create failed"
          echo "Output was: $NEW_PR_URL"
          echo "::endgroup::"
          # #endregion
          echo "Failed to create PR"
          echo "pr_created=false" >> $GITHUB_OUTPUT
          exit 1
        }

        # #region agent log - DEBUG: PR created successfully
        echo "::group::DEBUG - PR Created Successfully"
        echo "NEW_PR_URL=$NEW_PR_URL"
        echo "::endgroup::"
        # #endregion

        # Extract PR number from URL
        PR_NUMBER=$(echo "$NEW_PR_URL" | grep -oE '[0-9]+$' || echo "")

        echo "pr_created=true" >> $GITHUB_OUTPUT
        echo "pr_url=$NEW_PR_URL" >> $GITHUB_OUTPUT
        echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
        echo "branch=$BRANCH" >> $GITHUB_OUTPUT

        echo "## âœ… PR Created" >> $GITHUB_STEP_SUMMARY
        echo "- PR URL: $NEW_PR_URL" >> $GITHUB_STEP_SUMMARY
        echo "- PR Number: #$PR_NUMBER" >> $GITHUB_STEP_SUMMARY
        echo "- Branch: $BRANCH" >> $GITHUB_STEP_SUMMARY

    # Step 8: Send Slack Notification
    - name: Send Slack notification
      if: steps.create-pr.outputs.pr_created == 'true'
      shell: bash
      env:
        SLACK_WEBHOOK_URL: ${{ inputs.slack_webhook_url }}
        SLACK_USERS: ${{ inputs.slack_users_to_tag }}
        REPOSITORY: ${{ inputs.repository }}
        COMMIT_SHA: ${{ inputs.commit_sha }}
        PR_CREATED: ${{ steps.create-pr.outputs.pr_created }}
        PR_URL: ${{ steps.create-pr.outputs.pr_url }}
        HAS_UPDATES: ${{ steps.update-files.outputs.has_updates }}
        FILES_UPDATED: ${{ steps.update-files.outputs.files_updated }}
        API_SUCCESS: ${{ steps.analyze.outputs.api_success }}
      run: |
        set -e

        # #region agent log - DEBUG: Slack notification entry
        echo "::group::DEBUG - Slack Notification Entry"
        echo "PR_CREATED=$PR_CREATED"
        echo "PR_URL=$PR_URL"
        echo "HAS_UPDATES=$HAS_UPDATES"
        echo "FILES_UPDATED=$FILES_UPDATED"
        echo "SLACK_WEBHOOK_URL is set: $(test -n "$SLACK_WEBHOOK_URL" && echo 'yes' || echo 'no')"
        echo "SLACK_USERS=$SLACK_USERS"
        echo "::endgroup::"
        # #endregion

        echo "Sending Slack notification..."

        # Format Slack user mentions (convert "U123,U456" to "<@U123> <@U456>")
        FORMATTED_USERS=""
        if [ -n "$SLACK_USERS" ]; then
          FORMATTED_USERS=$(echo "$SLACK_USERS" | tr ',' '\n' | sed 's/^/<@/' | sed 's/$/>/' | tr '\n' ' ')
        fi

        # Read reasoning
        REASONING=$(cat /tmp/claude_decision.json 2>/dev/null | jq -r '.reasoning' || echo "N/A")

        # Build Slack message for PR created
        SLACK_MESSAGE=$(jq -n \
          --arg repo "$REPOSITORY" \
          --arg pr_url "$PR_URL" \
          --arg files "$FILES_UPDATED" \
          --arg commit "$COMMIT_SHA" \
          --arg reasoning "$REASONING" \
          --arg users "$FORMATTED_USERS" \
          '{
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": (if $users != "" then "\($users)\n" else "" end) + "ðŸ“š *Documentation Sync PR Created*\n<\($pr_url)|View PR> in `\($repo)`"
                }
              },
              {
                "type": "section",
                "fields": [
                  {
                    "type": "mrkdwn",
                    "text": "*Files Updated:*\n\($files)"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Commit:*\n`\($commit)`"
                  }
                ]
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Reasoning:*\n\($reasoning)"
                }
              },
              {
                "type": "context",
                "elements": [{
                  "type": "mrkdwn",
                  "text": "ðŸ¤– doc_sync_agent | Powered by Claude AI"
                }]
              }
            ]
          }')

        # #region agent log - DEBUG: Slack message built
        echo "::group::DEBUG - Slack Message"
        echo "SLACK_MESSAGE length: ${#SLACK_MESSAGE}"
        echo "$SLACK_MESSAGE" | head -c 500
        echo "::endgroup::"
        # #endregion

        # Send to Slack
        SLACK_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$SLACK_WEBHOOK_URL" \
          -H "Content-Type: application/json" \
          -d "$SLACK_MESSAGE") || {
          echo "Warning: Failed to send Slack notification"
        }
        
        HTTP_CODE=$(echo "$SLACK_RESPONSE" | tail -1)
        RESPONSE_BODY=$(echo "$SLACK_RESPONSE" | sed '$d')

        # #region agent log - DEBUG: Slack response
        echo "::group::DEBUG - Slack Response"
        echo "HTTP Code: $HTTP_CODE"
        echo "Response: $RESPONSE_BODY"
        echo "::endgroup::"
        # #endregion

        if [ "$HTTP_CODE" = "200" ]; then
          echo "Slack notification sent successfully"
        else
          echo "Warning: Slack notification may have failed (HTTP $HTTP_CODE)"
        fi

    # Step 9: Finalize and Set Status
    - name: Finalize
      id: finalize
      if: always()
      shell: bash
      run: |
        if [ "${{ steps.create-pr.outputs.pr_created }}" = "true" ]; then
          echo "status=success" >> $GITHUB_OUTPUT
        elif [ "${{ steps.update-files.outputs.has_updates }}" = "false" ]; then
          echo "status=skipped" >> $GITHUB_OUTPUT
        elif [ "${{ steps.analyze.outputs.api_success }}" = "false" ]; then
          echo "status=failed" >> $GITHUB_OUTPUT
        else
          echo "status=failed" >> $GITHUB_OUTPUT
        fi
