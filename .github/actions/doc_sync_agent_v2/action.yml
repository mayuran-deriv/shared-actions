name: 'Doc Sync Agent v2'
description: 'Automatically detects PR merges and updates documentation by adding new content only'
author: 'Deriv'

inputs:
  github_token:
    description: 'GitHub PAT with contents:write and pull-requests:write permissions'
    required: true
  anthropic_api_key:
    description: 'Anthropic API key for Claude'
    required: true
  slack_webhook_url:
    description: 'Slack webhook URL for notifications'
    required: true
  slack_users_to_tag:
    description: 'Comma-separated Slack user IDs to tag in notifications (e.g., U123ABC,U456DEF)'
    required: false
    default: ''
  repository:
    description: 'Repository name (owner/repo)'
    required: true
  commit_sha:
    description: 'Commit SHA that triggered this workflow'
    required: true
  base_branch:
    description: 'Base branch name (main or master)'
    required: false
    default: 'master'

outputs:
  pr_created:
    description: 'Whether a PR was created (true/false)'
    value: ${{ steps.create-pr.outputs.pr_created }}
  pr_url:
    description: 'URL of the created PR (if any)'
    value: ${{ steps.create-pr.outputs.pr_url }}
  pr_number:
    description: 'Number of the created PR (if any)'
    value: ${{ steps.create-pr.outputs.pr_number }}
  files_updated:
    description: 'Comma-separated list of files updated'
    value: ${{ steps.update-files.outputs.files_updated }}
  status:
    description: 'Overall status (success/skipped/failed)'
    value: ${{ steps.finalize.outputs.status }}

runs:
  using: 'composite'
  steps:
    # Step 1: Detect and Validate PR Merge
    - name: ðŸŽ¯ Detect and validate PR merge to master
      id: pr-validation
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        COMMIT_SHA: ${{ inputs.commit_sha }}
        BASE_BRANCH: ${{ inputs.base_branch }}
      run: |
        set -e

        echo "================================================"
        echo "ðŸ” DETECTING PR MERGE TO $BASE_BRANCH"
        echo "================================================"
        echo "Commit SHA: $COMMIT_SHA"
        echo ""

        # Get current branch
        CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
        echo "ðŸ“Œ Current branch: $CURRENT_BRANCH"

        # Find merged PR from commit SHA
        echo "ðŸ”Ž Searching for merged PR associated with commit..."
        PR_INFO=$(gh pr list --search "$COMMIT_SHA" --state merged --json number,title,url,mergedAt,baseRefName --jq '.[0]' || echo '{}')

        PR_NUMBER=$(echo "$PR_INFO" | jq -r '.number // empty')
        PR_TITLE=$(echo "$PR_INFO" | jq -r '.title // empty')
        PR_URL=$(echo "$PR_INFO" | jq -r '.url // empty')
        PR_BASE=$(echo "$PR_INFO" | jq -r '.baseRefName // empty')

        # Validate this is a merge to master
        if [ -z "$PR_NUMBER" ] || [ "$PR_NUMBER" = "null" ]; then
          echo "âŒ No merged PR found for this commit"
          echo "âš ï¸  This workflow only processes PR merges to $BASE_BRANCH"
          echo "is_pr_merge=false" >> $GITHUB_OUTPUT
          echo "## â­ï¸ Skipped - Not a PR Merge" >> $GITHUB_STEP_SUMMARY
          echo "This commit is not associated with a merged PR." >> $GITHUB_STEP_SUMMARY
          exit 0
        fi

        if [ "$PR_BASE" != "$BASE_BRANCH" ]; then
          echo "âŒ PR #$PR_NUMBER was not merged to $BASE_BRANCH (merged to: $PR_BASE)"
          echo "âš ï¸  This workflow only processes merges to $BASE_BRANCH"
          echo "is_pr_merge=false" >> $GITHUB_OUTPUT
          echo "## â­ï¸ Skipped - Wrong Target Branch" >> $GITHUB_STEP_SUMMARY
          echo "PR #$PR_NUMBER was merged to \`$PR_BASE\`, not \`$BASE_BRANCH\`" >> $GITHUB_STEP_SUMMARY
          exit 0
        fi

        echo "âœ… Valid PR merge detected!"
        echo "   PR #$PR_NUMBER: $PR_TITLE"
        echo "   Merged to: $PR_BASE"
        echo ""

        echo "is_pr_merge=true" >> $GITHUB_OUTPUT
        echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
        echo "pr_title=$PR_TITLE" >> $GITHUB_OUTPUT
        echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT

        echo "## âœ… PR Merge Detected" >> $GITHUB_STEP_SUMMARY
        echo "- **PR Number:** #$PR_NUMBER" >> $GITHUB_STEP_SUMMARY
        echo "- **Title:** $PR_TITLE" >> $GITHUB_STEP_SUMMARY
        echo "- **Merged to:** \`$PR_BASE\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit:** \`$COMMIT_SHA\`" >> $GITHUB_STEP_SUMMARY

    # Step 2: Check for Existing Documentation Files
    - name: ðŸ“„ Check existing documentation files
      id: check-docs
      if: steps.pr-validation.outputs.is_pr_merge == 'true'
      shell: bash
      run: |
        set -e

        echo "================================================"
        echo "ðŸ“„ CHECKING EXISTING DOCUMENTATION FILES"
        echo "================================================"

        README_EXISTS="false"
        CLAUDE_MD_EXISTS="false"

        if [ -f "README.md" ]; then
          README_EXISTS="true"
          README_SIZE=$(wc -l < README.md | tr -d ' ')
          echo "âœ… README.md found ($README_SIZE lines)"
        else
          echo "âŒ README.md not found"
        fi

        if [ -f "CLAUDE.md" ]; then
          CLAUDE_MD_EXISTS="true"
          CLAUDE_SIZE=$(wc -l < CLAUDE.md | tr -d ' ')
          echo "âœ… CLAUDE.md found ($CLAUDE_SIZE lines)"
        else
          echo "âŒ CLAUDE.md not found"
        fi

        echo ""
        echo "readme_exists=$README_EXISTS" >> $GITHUB_OUTPUT
        echo "claude_md_exists=$CLAUDE_MD_EXISTS" >> $GITHUB_OUTPUT

        # If no documentation files exist, skip
        if [ "$README_EXISTS" = "false" ] && [ "$CLAUDE_MD_EXISTS" = "false" ]; then
          echo "âš ï¸  No existing documentation files found to update"
          echo "âš ï¸  This action only updates existing documentation"
          echo "has_docs=false" >> $GITHUB_OUTPUT
          echo "## â­ï¸ Skipped - No Existing Documentation" >> $GITHUB_STEP_SUMMARY
          echo "No README.md or CLAUDE.md found in repository root." >> $GITHUB_STEP_SUMMARY
          exit 0
        fi

        echo "has_docs=true" >> $GITHUB_OUTPUT

        echo "## ðŸ“„ Documentation Files" >> $GITHUB_STEP_SUMMARY
        if [ "$README_EXISTS" = "true" ]; then
          echo "- âœ… README.md exists" >> $GITHUB_STEP_SUMMARY
        else
          echo "- âŒ README.md does not exist" >> $GITHUB_STEP_SUMMARY
        fi
        if [ "$CLAUDE_MD_EXISTS" = "true" ]; then
          echo "- âœ… CLAUDE.md exists" >> $GITHUB_STEP_SUMMARY
        else
          echo "- âŒ CLAUDE.md does not exist" >> $GITHUB_STEP_SUMMARY
        fi

    # Step 3: Generate Code Diff
    - name: ðŸ”„ Generate code diff from PR merge
      id: diff-context
      if: steps.check-docs.outputs.has_docs == 'true'
      shell: bash
      run: |
        set -e

        echo "================================================"
        echo "ðŸ”„ GENERATING CODE DIFF"
        echo "================================================"

        # Determine if this is a merge commit
        if git rev-parse --verify HEAD^2 2>/dev/null; then
          echo "ðŸ“¦ Detected merge commit"
          MERGE_BASE=$(git merge-base HEAD~1 HEAD)
          DIFF=$(git diff "$MERGE_BASE" HEAD 2>/dev/null || git diff HEAD~1 HEAD)
        else
          echo "ðŸ“ Regular commit, comparing with previous"
          DIFF=$(git diff HEAD~1 HEAD 2>/dev/null || echo "No diff available")
        fi

        # Filter noise (exclude lock files, binary files)
        echo "ðŸ§¹ Filtering out noise from diff..."
        FILTERED_DIFF=$(echo "$DIFF" | grep -v "package-lock.json" | grep -v "yarn.lock" | grep -v "pnpm-lock.yaml" | grep -v ".lock" | head -n 5000)

        # Count changed files
        CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | wc -l | tr -d ' ')
        CHANGED_FILES_LIST=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | head -n 20)

        echo "changed_files=$CHANGED_FILES" >> $GITHUB_OUTPUT

        # Save diff to file for next step
        echo "$FILTERED_DIFF" > /tmp/code_diff.txt

        echo ""
        echo "ðŸ“Š Diff Statistics:"
        echo "   Files changed: $CHANGED_FILES"
        echo "   Diff lines: $(echo "$FILTERED_DIFF" | wc -l | tr -d ' ')"
        echo ""
        echo "ðŸ“ Changed files:"
        echo "$CHANGED_FILES_LIST" | sed 's/^/   - /'
        echo ""

        echo "## ðŸ”„ Code Changes Analyzed" >> $GITHUB_STEP_SUMMARY
        echo "- **Files changed:** $CHANGED_FILES" >> $GITHUB_STEP_SUMMARY
        echo "- **Diff lines:** $(echo "$FILTERED_DIFF" | wc -l) lines" >> $GITHUB_STEP_SUMMARY

    # Step 4: Read Current Documentation
    - name: ðŸ“– Read current documentation
      id: read-docs
      if: steps.check-docs.outputs.has_docs == 'true'
      shell: bash
      run: |
        set -e

        echo "================================================"
        echo "ðŸ“– READING CURRENT DOCUMENTATION"
        echo "================================================"

        # Read README.md
        if [ -f "README.md" ]; then
          README_CONTENT=$(cat README.md)
          echo "âœ… README.md loaded ($(echo "$README_CONTENT" | wc -l | tr -d ' ') lines)"
        else
          README_CONTENT=""
          echo "â­ï¸  README.md not found"
        fi

        # Read CLAUDE.md
        if [ -f "CLAUDE.md" ]; then
          CLAUDE_MD_CONTENT=$(cat CLAUDE.md)
          echo "âœ… CLAUDE.md loaded ($(echo "$CLAUDE_MD_CONTENT" | wc -l | tr -d ' ') lines)"
        else
          CLAUDE_MD_CONTENT=""
          echo "â­ï¸  CLAUDE.md not found"
        fi

        # Save content to files
        echo "$README_CONTENT" > /tmp/current_readme.txt
        echo "$CLAUDE_MD_CONTENT" > /tmp/current_claude_md.txt

        echo ""

    # Step 6: Analyze with Claude AI
    - name: ðŸ¤– Analyze changes with Claude AI
      id: analyze
      if: steps.check-docs.outputs.has_docs == 'true'
      shell: bash
      env:
        ANTHROPIC_API_KEY: ${{ inputs.anthropic_api_key }}
        REPOSITORY: ${{ inputs.repository }}
        PR_TITLE: ${{ steps.pr-validation.outputs.pr_title }}
        PR_NUMBER: ${{ steps.pr-validation.outputs.pr_number }}
        COMMIT_SHA: ${{ inputs.commit_sha }}
      run: |
        set -e

        echo "================================================"
        echo "ðŸ¤– CALLING CLAUDE AI FOR ANALYSIS"
        echo "================================================"

        # Read prepared files
        DIFF_CONTENT=$(cat /tmp/code_diff.txt)
        README_CONTENT=$(cat /tmp/current_readme.txt)
        CLAUDE_MD_CONTENT=$(cat /tmp/current_claude_md.txt)

        # Build system prompt
        SYSTEM_PROMPT="You are an expert technical documentation specialist with deep expertise in:
        - Identifying when code changes require documentation updates
        - Adding new information to existing documentation without altering existing content
        - Understanding what constitutes a significant change vs. minor implementation detail
        - Maintaining documentation consistency and style

        Your role is to analyze code changes from a merged PR and determine if existing documentation needs updates. You ONLY add new information when truly necessary - you never modify or remove existing content.

        CRITICAL RULES:
        1. **ONLY UPDATE EXISTING DOCUMENTATION FILES** - Never create new documentation files
        2. **ONLY ADD NEW CONTENT** - Never modify, remove, or alter existing documentation content
        3. **BE CONSERVATIVE** - Only add documentation when code changes introduce genuinely new user-facing features or important architectural changes
        4. **PRESERVE EVERYTHING** - Keep all existing sections, formatting, style, and content exactly as is
        5. **ADD SECTIONS APPROPRIATELY** - When adding new content, place it in the most logical location or create a new section at the end

        WHAT REQUIRES DOCUMENTATION UPDATES:
        - New features or functionality added to the codebase
        - New API endpoints, methods, or public interfaces
        - New configuration options or environment variables
        - New setup/installation steps required
        - New dependencies that affect usage
        - Major architectural changes that affect how the project works
        - New tools, utilities, or scripts added

        WHAT DOES NOT REQUIRE DOCUMENTATION UPDATES:
        - Bug fixes that restore existing functionality
        - Internal code refactoring
        - Performance optimizations
        - Code style/formatting changes
        - Dependency version bumps (unless they change usage)
        - Test file changes
        - CI/CD configuration tweaks
        - Minor UI/styling adjustments
        - Internal variable/function renames
        - Documentation-only changes

        APPROACH TO ADDING CONTENT:
        - Read the existing documentation thoroughly
        - Identify if the code changes introduce something genuinely new
        - If yes, add a new section or extend an existing section with the new information
        - Match the existing writing style, tone, and formatting exactly
        - Place new content logically (e.g., new features under Features section)
        - If no appropriate section exists, add a new section at the end
        - Keep additions concise and relevant"

        # Build user prompt
        USER_PROMPT="Repository: $REPOSITORY
        Merged PR: #$PR_NUMBER - $PR_TITLE
        Commit SHA: $COMMIT_SHA

        ## Code Changes from Merged PR
        \`\`\`diff
        $DIFF_CONTENT
        \`\`\`

        ## Current README.md
        $(if [ -n "$README_CONTENT" ]; then echo "\`\`\`markdown"; echo "$README_CONTENT"; echo "\`\`\`"; else echo "(File does not exist - skip this file)"; fi)

        ## Current CLAUDE.md
        $(if [ -n "$CLAUDE_MD_CONTENT" ]; then echo "\`\`\`markdown"; echo "$CLAUDE_MD_CONTENT"; echo "\`\`\`"; else echo "(File does not exist - skip this file)"; fi)

        ## Your Task
        Analyze the code changes and determine:

        1. **For README.md (if it exists):**
           - Do these changes introduce something new that users need to know about?
           - If yes, what new content should be ADDED to the existing documentation?
           - Where should the new content be placed?

        2. **For CLAUDE.md (if it exists):**
           - Do these changes affect AI/LLM integration, Claude workflows, or development guidelines?
           - If yes, what new content should be ADDED to the existing documentation?

        ## Response Format
        Respond ONLY with valid JSON in this exact structure (no markdown code blocks, just raw JSON):
        {
          \"should_update_readme\": boolean,
          \"should_update_claude_md\": boolean,
          \"readme_content\": \"COMPLETE updated README.md content with new sections/information ADDED (only if should_update_readme is true AND file exists, otherwise empty string)\",
          \"claude_md_content\": \"COMPLETE updated CLAUDE.md content with new sections/information ADDED (only if should_update_claude_md is true AND file exists, otherwise empty string)\",
          \"reasoning\": \"Brief explanation of your decision (2-4 sentences) - explain what new content was added and why, or why no update is needed\"
        }

        ## Critical Guidelines
        - Only set should_update_* to true if genuinely new user-facing information needs to be added
        - If updating, provide the COMPLETE file content with new content added to existing content
        - Never modify or remove existing content - only append or insert new sections
        - Preserve all existing formatting, style, structure, and tone
        - Match the writing style of the existing documentation exactly
        - Be conservative - when in doubt, skip the update
        - If a documentation file doesn't exist, set should_update to false for that file"

        # Call Claude API with timeout
        echo "ðŸ”„ Sending request to Claude API..."
        echo "   Model: claude-3-7-sonnet-latest"
        echo "   Max tokens: 8000"
        echo ""

        RESPONSE=$(timeout 120s curl -s -X POST "https://api.anthropic.com/v1/messages" \
          -H "x-api-key: $ANTHROPIC_API_KEY" \
          -H "anthropic-version: 2023-06-01" \
          -H "content-type: application/json" \
          -d "$(jq -n \
            --arg system "$SYSTEM_PROMPT" \
            --arg user "$USER_PROMPT" \
            '{
              "model": "claude-3-7-sonnet-latest",
              "max_tokens": 8000,
              "temperature": 0.3,
              "system": $system,
              "messages": [{
                "role": "user",
                "content": $user
              }]
            }')" || {
          echo "âŒ Claude API call failed or timed out"
          echo "api_success=false" >> $GITHUB_OUTPUT
          exit 1
        })

        # Check for API errors
        ERROR_MSG=$(echo "$RESPONSE" | jq -r '.error.message // empty')
        if [ -n "$ERROR_MSG" ]; then
          echo "âŒ Claude API error: $ERROR_MSG"
          echo "api_success=false" >> $GITHUB_OUTPUT
          echo "error_message=$ERROR_MSG" >> $GITHUB_OUTPUT
          exit 1
        fi

        # Extract content from response
        CLAUDE_DECISION=$(echo "$RESPONSE" | jq -r '.content[0].text')

        # Save to file
        echo "$CLAUDE_DECISION" > /tmp/claude_decision.json

        echo "âœ… Claude AI analysis complete"
        echo ""
        echo "api_success=true" >> $GITHUB_OUTPUT

        echo "## ðŸ¤– Claude AI Analysis Complete" >> $GITHUB_STEP_SUMMARY

    # Step 7: Parse Decision & Update Files
    - name: ðŸ“ Parse decision and update files
      id: update-files
      if: steps.analyze.outputs.api_success == 'true'
      shell: bash
      run: |
        set -e

        echo "================================================"
        echo "ðŸ“ PARSING CLAUDE AI DECISION"
        echo "================================================"

        # Read Claude's response
        CLAUDE_DECISION=$(cat /tmp/claude_decision.json)

        # Validate JSON
        if ! echo "$CLAUDE_DECISION" | jq empty 2>/dev/null; then
          echo "âŒ Invalid JSON response from Claude"
          echo "valid_json=false" >> $GITHUB_OUTPUT
          echo "Response: $CLAUDE_DECISION"
          exit 1
        fi

        echo "âœ… Valid JSON response received"
        echo "valid_json=true" >> $GITHUB_OUTPUT

        # Extract decision
        SHOULD_UPDATE_README=$(echo "$CLAUDE_DECISION" | jq -r '.should_update_readme')
        SHOULD_UPDATE_CLAUDE_MD=$(echo "$CLAUDE_DECISION" | jq -r '.should_update_claude_md')
        REASONING=$(echo "$CLAUDE_DECISION" | jq -r '.reasoning')

        echo ""
        echo "ðŸ“Š Decision Summary:"
        echo "   Update README.md: $SHOULD_UPDATE_README"
        echo "   Update CLAUDE.md: $SHOULD_UPDATE_CLAUDE_MD"
        echo ""
        echo "ðŸ’­ Reasoning:"
        echo "   $REASONING"
        echo ""

        echo "should_update_readme=$SHOULD_UPDATE_README" >> $GITHUB_OUTPUT
        echo "should_update_claude_md=$SHOULD_UPDATE_CLAUDE_MD" >> $GITHUB_OUTPUT
        echo "reasoning<<EOF" >> $GITHUB_OUTPUT
        echo "$REASONING" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

        # Check if any updates needed
        if [ "$SHOULD_UPDATE_README" = "false" ] && [ "$SHOULD_UPDATE_CLAUDE_MD" = "false" ]; then
          echo "âœ… No documentation updates needed"
          echo "has_updates=false" >> $GITHUB_OUTPUT
          echo "## âœ… No Updates Needed" >> $GITHUB_STEP_SUMMARY
          echo "$REASONING" >> $GITHUB_STEP_SUMMARY
          exit 0
        fi

        echo "has_updates=true" >> $GITHUB_OUTPUT

        echo "================================================"
        echo "âœï¸  UPDATING DOCUMENTATION FILES"
        echo "================================================"

        # Update files
        UPDATED_FILES=""

        if [ "$SHOULD_UPDATE_README" = "true" ]; then
          echo "ðŸ“ Processing README.md update..."
          README_CONTENT=$(echo "$CLAUDE_DECISION" | jq -r '.readme_content')

          # Validate content is not empty
          if [ -z "$README_CONTENT" ] || [ "$README_CONTENT" = "null" ]; then
            echo "âš ï¸  WARNING: README content is empty, skipping"
          else
            # Write new content
            echo "$README_CONTENT" > README.md

            # Verify content actually changed using git
            if git diff --exit-code README.md > /dev/null 2>&1; then
              echo "âš ï¸  WARNING: README.md content unchanged - no actual changes detected"
            else
              UPDATED_FILES="README.md"
              echo "âœ… README.md updated successfully"
            fi
          fi
        fi

        if [ "$SHOULD_UPDATE_CLAUDE_MD" = "true" ]; then
          echo "ðŸ“ Processing CLAUDE.md update..."
          CLAUDE_MD_CONTENT=$(echo "$CLAUDE_DECISION" | jq -r '.claude_md_content')

          # Validate content is not empty
          if [ -z "$CLAUDE_MD_CONTENT" ] || [ "$CLAUDE_MD_CONTENT" = "null" ]; then
            echo "âš ï¸  WARNING: CLAUDE.md content is empty, skipping"
          else
            # Write new content
            echo "$CLAUDE_MD_CONTENT" > CLAUDE.md

            # Verify content actually changed using git
            if git diff --exit-code CLAUDE.md > /dev/null 2>&1; then
              echo "âš ï¸  WARNING: CLAUDE.md content unchanged - no actual changes detected"
            else
              if [ -n "$UPDATED_FILES" ]; then
                UPDATED_FILES="$UPDATED_FILES,CLAUDE.md"
              else
                UPDATED_FILES="CLAUDE.md"
              fi
              echo "âœ… CLAUDE.md updated successfully"
            fi
          fi
        fi

        echo "files_updated=$UPDATED_FILES" >> $GITHUB_OUTPUT

        echo ""
        echo "================================================"
        echo "âœ… FILE UPDATES COMPLETE"
        echo "================================================"
        echo "Updated files: $UPDATED_FILES"
        echo ""

        # Debug: Check git status
        echo "ðŸ” Git status after file updates:"
        git status --short
        echo ""
        echo "ðŸ” Git diff summary:"
        git diff --stat
        echo ""

        echo "## ðŸ“ Files Updated" >> $GITHUB_STEP_SUMMARY
        echo "**Files:** $UPDATED_FILES" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Reasoning:** $REASONING" >> $GITHUB_STEP_SUMMARY

    # Step 8: Create Pull Request
    - name: ðŸŽ¯ Create documentation update PR
      id: create-pr
      if: steps.update-files.outputs.has_updates == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        BASE_BRANCH: ${{ inputs.base_branch }}
        COMMIT_SHA: ${{ inputs.commit_sha }}
        REPOSITORY: ${{ inputs.repository }}
        PR_URL: ${{ steps.pr-validation.outputs.pr_url }}
        PR_NUMBER: ${{ steps.pr-validation.outputs.pr_number }}
      run: |
        set -e

        echo "================================================"
        echo "ðŸŽ¯ CREATING PULL REQUEST"
        echo "================================================"

        # Debug: Check git status BEFORE creating branch
        echo "ðŸ” Git status before creating branch:"
        git status --short
        echo ""
        echo "ðŸ” Git diff before creating branch:"
        git diff --name-only
        echo ""

        # Configure git
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        # Create timestamped branch
        BRANCH="docs/auto-sync-$(date +%Y%m%d-%H%M%S)"
        echo "ðŸ“Œ Creating branch: $BRANCH"
        git checkout -b "$BRANCH"

        # Debug: Check git status AFTER creating branch
        echo "ðŸ” Git status after creating branch:"
        git status --short
        echo ""

        # Get reasoning from previous step
        REASONING=$(cat /tmp/claude_decision.json | jq -r '.reasoning')
        FILES_UPDATED="${{ steps.update-files.outputs.files_updated }}"

        # Stage changes
        git add README.md CLAUDE.md 2>/dev/null || true

        # Check if there are changes to commit
        if git diff --cached --quiet; then
          echo "âš ï¸  No changes to commit after staging"
          echo "pr_created=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Commit
        echo "ðŸ’¾ Committing changes..."
        git commit -m "docs: Auto-sync documentation for PR #$PR_NUMBER

        Updates documentation based on code changes from merged PR.

        Co-Authored-By: Claude Sonnet <noreply@anthropic.com>"

        # Push branch
        echo "â¬†ï¸  Pushing branch to remote..."
        git push origin "$BRANCH"

        # Build PR body
        FILES_LIST=$(echo "$FILES_UPDATED" | tr ',' '\n' | sed 's/^/- /')

        # Create PR body
        PR_BODY=$(printf "%s\n\n%s\n\n%s\n%s\n\n%s\n%s\n\n%s\n%s\n%s\n\n%s\n%s" \
          "## ðŸ“š Automated Documentation Update" \
          "This PR was automatically generated to keep documentation synchronized with code changes." \
          "### ðŸ“ Files Updated" \
          "$FILES_LIST" \
          "### ðŸ¤– AI Analysis" \
          "$REASONING" \
          "### ðŸ”— Triggered By" \
          "- **Original PR:** #$PR_NUMBER" \
          "- **Commit:** \`$COMMIT_SHA\`" \
          "---" \
          "ðŸ¤– *Generated by doc_sync_agent v2 | Powered by Claude AI*")

        # Create PR
        echo "ðŸ“¤ Creating pull request..."
        NEW_PR_URL=$(gh pr create \
          --title "ðŸ“š docs: Auto-sync documentation for PR #$PR_NUMBER" \
          --body "$PR_BODY" \
          --base "$BASE_BRANCH" \
          --head "$BRANCH") || {
          echo "âŒ Failed to create PR"
          echo "pr_created=false" >> $GITHUB_OUTPUT
          exit 1
        }

        # Extract PR number from URL
        NEW_PR_NUMBER=$(echo "$NEW_PR_URL" | grep -oE '[0-9]+$' || echo "")

        echo ""
        echo "âœ… Pull request created successfully!"
        echo "   URL: $NEW_PR_URL"
        echo "   PR #$NEW_PR_NUMBER"
        echo "   Branch: $BRANCH"
        echo ""

        echo "pr_created=true" >> $GITHUB_OUTPUT
        echo "pr_url=$NEW_PR_URL" >> $GITHUB_OUTPUT
        echo "pr_number=$NEW_PR_NUMBER" >> $GITHUB_OUTPUT
        echo "branch=$BRANCH" >> $GITHUB_OUTPUT

        echo "## âœ… Documentation PR Created" >> $GITHUB_STEP_SUMMARY
        echo "- **PR URL:** $NEW_PR_URL" >> $GITHUB_STEP_SUMMARY
        echo "- **PR Number:** #$NEW_PR_NUMBER" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch:** \`$BRANCH\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "âš ï¸  **Note:** This PR requires manual review and approval before merging." >> $GITHUB_STEP_SUMMARY

    # Step 9: Send Slack Notification
    - name: ðŸ“¢ Send Slack notification
      if: steps.create-pr.outputs.pr_created == 'true'
      shell: bash
      env:
        SLACK_WEBHOOK_URL: ${{ inputs.slack_webhook_url }}
        SLACK_USERS: ${{ inputs.slack_users_to_tag }}
        REPOSITORY: ${{ inputs.repository }}
        COMMIT_SHA: ${{ inputs.commit_sha }}
        PR_CREATED: ${{ steps.create-pr.outputs.pr_created }}
        PR_URL: ${{ steps.create-pr.outputs.pr_url }}
        PR_NUMBER: ${{ steps.create-pr.outputs.pr_number }}
        ORIGINAL_PR: ${{ steps.pr-validation.outputs.pr_number }}
        FILES_UPDATED: ${{ steps.update-files.outputs.files_updated }}
      run: |
        set -e

        echo "================================================"
        echo "ðŸ“¢ SENDING SLACK NOTIFICATION"
        echo "================================================"

        # Format Slack user mentions (convert "U123,U456" to "<@U123> <@U456>")
        FORMATTED_USERS=""
        if [ -n "$SLACK_USERS" ]; then
          FORMATTED_USERS=$(echo "$SLACK_USERS" | tr ',' '\n' | sed 's/^/<@/' | sed 's/$/>/' | tr '\n' ' ')
          echo "ðŸ‘¥ Tagging users: $FORMATTED_USERS"
        fi

        # Read reasoning
        REASONING=$(cat /tmp/claude_decision.json 2>/dev/null | jq -r '.reasoning' || echo "Documentation updated based on code changes")

        # Build Slack message
        SLACK_MESSAGE=$(jq -n \
          --arg repo "$REPOSITORY" \
          --arg pr_url "$PR_URL" \
          --arg pr_number "$PR_NUMBER" \
          --arg original_pr "$ORIGINAL_PR" \
          --arg files "$FILES_UPDATED" \
          --arg commit "$COMMIT_SHA" \
          --arg reasoning "$REASONING" \
          --arg users "$FORMATTED_USERS" \
          '{
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": (if $users != "" then "\($users)\n" else "" end) + "ðŸ“š *Documentation Update Required*\n<\($pr_url)|View PR #\($pr_number)> in `\($repo)`"
                }
              },
              {
                "type": "section",
                "fields": [
                  {
                    "type": "mrkdwn",
                    "text": "*Files Updated:*\n\($files)"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Original PR:*\n#\($original_pr)"
                  }
                ]
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*AI Analysis:*\n\($reasoning)"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "âš ï¸ *Action Required:* Please review and approve the documentation changes"
                }
              },
              {
                "type": "context",
                "elements": [{
                  "type": "mrkdwn",
                  "text": "ðŸ¤– doc_sync_agent v2 | Powered by Claude AI"
                }]
              }
            ]
          }')

        # Send to Slack
        echo "ðŸ“¤ Posting to Slack webhook..."
        curl -X POST "$SLACK_WEBHOOK_URL" \
          -H "Content-Type: application/json" \
          -d "$SLACK_MESSAGE" || {
          echo "âš ï¸  WARNING: Failed to send Slack notification"
        }

        echo "âœ… Slack notification sent"
        echo ""

    # Step 10: Finalize and Set Status
    - name: ðŸ Finalize workflow
      id: finalize
      if: always()
      shell: bash
      run: |
        echo "================================================"
        echo "ðŸ WORKFLOW COMPLETE"
        echo "================================================"

        if [ "${{ steps.pr-validation.outputs.is_pr_merge }}" != "true" ]; then
          echo "status=skipped" >> $GITHUB_OUTPUT
          echo "Result: Skipped (not a PR merge to master)"
        elif [ "${{ steps.check-docs.outputs.has_docs }}" != "true" ]; then
          echo "status=skipped" >> $GITHUB_OUTPUT
          echo "Result: Skipped (no existing documentation)"
        elif [ "${{ steps.create-pr.outputs.pr_created }}" = "true" ]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "Result: Success (PR created)"
        elif [ "${{ steps.update-files.outputs.has_updates }}" = "false" ]; then
          echo "status=skipped" >> $GITHUB_OUTPUT
          echo "Result: Skipped (no updates needed)"
        elif [ "${{ steps.analyze.outputs.api_success }}" = "false" ]; then
          echo "status=failed" >> $GITHUB_OUTPUT
          echo "Result: Failed (API error)"
        else
          echo "status=failed" >> $GITHUB_OUTPUT
          echo "Result: Failed (unknown error)"
        fi

        echo "================================================"
